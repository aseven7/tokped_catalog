package main

import "encoding/json"
import "fmt"
import "net/http"
import "io/ioutil"
import "bytes"
import "strings"
import "os"
// import "reflect"

var tokped_url string = "https://tokopedia.com/%v"
var tokped_product_url string = "https://ace.tokopedia.com/search/v2.6/product?shop_id=%s&ob=11&rows=200&start=%d&full_domain=www.tokopedia.com&scheme=https&device=desktop&source=shop_product"
var current_file_dir string = ""

/***
 * Auto-Generated by JSON-to-Go
 * 
 * Â© 2015 Matt Holt - View on GitHub - dark mode 
 * The Go Gopher artwork is a derivative of that by Renee French.
 ***/
type ProductData struct {
	Status struct {
		ErrorCode int    `json:"error_code"`
		Message   string `json:"message"`
	} `json:"status"`
	Header struct {
		TotalData         int         `json:"total_data"`
		AdditionalParams  string      `json:"additional_params"`
		ProcessTime       float64     `json:"process_time"`
		SuggestionInstead interface{} `json:"suggestion_instead"`
	} `json:"header"`
	Data []struct {
		ID          int    `json:"id"`
		Name        string `json:"name"`
		URI         string `json:"uri"`
		ImageURI    string `json:"image_uri"`
		ImageURI700 string `json:"image_uri_700"`
		Price       string `json:"price"`
		Shop        struct {
			ID                 int         `json:"id"`
			Name               string      `json:"name"`
			URI                string      `json:"uri"`
			IsGold             int         `json:"is_gold"`
			Rating             interface{} `json:"rating"`
			Location           string      `json:"location"`
			ReputationImageURI string      `json:"reputation_image_uri"`
			ShopLucky          string      `json:"shop_lucky"`
			City               string      `json:"city"`
		} `json:"shop"`
		Condition    int `json:"condition"`
		Preorder     int `json:"preorder"`
		DepartmentID int `json:"department_id"`
		Rating       int `json:"rating"`
		CountReview  int `json:"count_review"`
		CountTalk    int `json:"count_talk"`
		CountSold    int `json:"count_sold"`
		Badges       []struct {
			Title    string `json:"title"`
			ImageURL string `json:"image_url"`
		} `json:"badges"`
		OriginalPrice      string      `json:"original_price"`
		DiscountExpired    interface{} `json:"discount_expired"`
		DiscountPercentage int         `json:"discount_percentage"`
	} `json:"data"`
	Category struct {
		SelectedID string `json:"selected_id"`
	} `json:"category"`
}


type ProductDataItem struct {
	ID          int    `json:"id"`
	Name        string `json:"name"`
	URI         string `json:"uri"`
	ImageURI    string `json:"image_uri"`
	ImageURI700 string `json:"image_uri_700"`
	Price       string `json:"price"`
	Shop        struct {
		ID                 int         `json:"id"`
		Name               string      `json:"name"`
		URI                string      `json:"uri"`
		IsGold             int         `json:"is_gold"`
		Rating             interface{} `json:"rating"`
		Location           string      `json:"location"`
		ReputationImageURI string      `json:"reputation_image_uri"`
		ShopLucky          string      `json:"shop_lucky"`
		City               string      `json:"city"`
	} `json:"shop"`
	Condition    int `json:"condition"`
	Preorder     int `json:"preorder"`
	DepartmentID int `json:"department_id"`
	Rating       int `json:"rating"`
	CountReview  int `json:"count_review"`
	CountTalk    int `json:"count_talk"`
	CountSold    int `json:"count_sold"`
	Badges       []struct {
		Title    string `json:"title"`
		ImageURL string `json:"image_url"`
	} `json:"badges"`
	OriginalPrice      string      `json:"original_price"`
	DiscountExpired    interface{} `json:"discount_expired"`
	DiscountPercentage int         `json:"discount_percentage"`
}

func tokped_fetch_store_id(tokped_store_name string) (store_id string) {
	var json_output []byte

	var target_url = fmt.Sprintf(tokped_url, tokped_store_name)

	req, err := http.NewRequest("GET", target_url, bytes.NewBuffer(json_output))

	req.Header.Set("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36")

	var http_client = &http.Client{}

	res, err := http_client.Do(req)

	if err != nil {
		panic(err)
	}

	defer res.Body.Close()

    body, _ := ioutil.ReadAll(res.Body)

    body_splitted_new_line := strings.Split(string(body), "\n")

    string_target_split := "var page_shop_id ="

    for i := 0; i < len(body_splitted_new_line); i++ {

    	if strings.Index(body_splitted_new_line[i], string_target_split) != -1 {
    		output := strings.Replace(body_splitted_new_line[i], string_target_split, "", 1)
    		output = strings.Replace(output, ";", "", 1)
    		output = strings.Trim(output, " ")
    		store_id = output
    		return
    	}
    }

    return
}

func tokped_fetch_store_product(tokped_store_id string, pivot_start int) (tokped_product_json ProductData) {
	var json_output []byte

	var target_url = fmt.Sprintf(tokped_product_url, tokped_store_id, pivot_start)

	fmt.Println(target_url)

	req, err := http.NewRequest("GET", target_url, bytes.NewBuffer(json_output))

	req.Header.Set("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36")

	var http_client = &http.Client{}

	res, err := http_client.Do(req)

	check_error(err)

	defer res.Body.Close()

    body, _ := ioutil.ReadAll(res.Body)

    json.Unmarshal(body, &tokped_product_json)

    return
}

func tokped_fetch_store_product_all(tokped_store_id string) (product_data_overall []interface{}){
	var product_data ProductData
	var pivot_start = 0

	for {

		product_data = tokped_fetch_store_product(tokped_store_id, pivot_start)
		
		for i:=0; i < len(product_data.Data); i++ {
			product_data_overall = append(product_data_overall, product_data.Data[i])
		}
		
		fmt.Println("Received : ", len(product_data.Data), " product (s)")

		fmt.Println()

		if len(product_data.Data) != 200 {
			break
		}

		pivot_start = pivot_start + 200
	}

	return

}

func check_error(e error) {
	if e != nil {
		fmt.Println(e)
	}
}

func create_json_file(destination_file string, json_output []byte) {
	f, err := os.Create(destination_file)

	check_error(err)

	defer f.Close()

	f.Write(json_output)

	f.Sync()
}

func web_server_process_fetch_handler() http.Handler {
  
  fn := func(w http.ResponseWriter, r *http.Request) {

  	store_name := r.URL.Query().Get("store_name")

  	if store_name != "" {
    	
		var store_name_list = []string{ store_name }

		for i := 0; i < len(store_name_list); i++ {
			
			store_id := tokped_fetch_store_id(store_name_list[i])

			fmt.Println("Fetching store : ", store_name_list[i])

			product_all := tokped_fetch_store_product_all(store_id)

			fmt.Println("Total product of ", store_name_list[i], " : ", len(product_all), " product (s)\n\n")

			json_output, err := json.Marshal(product_all)

			check_error(err)

		 	var destination_file string = current_file_dir + "\\..\\json\\" + store_name_list[i] + ".json"

			create_json_file(destination_file, json_output)

		}

		create_json_list_file()

  	}

  }

  return http.HandlerFunc(fn)
}

func running_web_server(port string) {

    file_handler := http.FileServer(http.Dir(current_file_dir + "/.."))

    if port == "" {

	    fmt.Printf("Please input port Number (default: 8088) : \n")

	    fmt.Scanf("%s", &port, "8088")
    }
	
	fmt.Println("Server running in port : ", port)

	// handler

	mux := http.NewServeMux()

	process_fetch_handler := web_server_process_fetch_handler()

	mux.Handle("/fetch", process_fetch_handler)

	mux.Handle("/", file_handler)

    http.ListenAndServe(":" + port, mux)

}

func create_json_list_file() {

	list_json_file, err := ioutil.ReadDir(current_file_dir + "\\..\\json")

	var list_file_name []string

	for i:=0; i < len(list_json_file); i++ {
		
		file_name := list_json_file[i].Name()

		list_file_name = append(list_file_name, file_name)
	}

	json_output, err := json.Marshal(list_file_name)

	check_error(err)

	var destination_file string = current_file_dir + "\\..\\list.json"

	create_json_file(destination_file, json_output)

}

func main() {

	dir, err := os.Getwd()

	current_file_dir = dir

	running_web_server("8081")

	check_error(err)
}